@if (Songs.Count > 0)
{
    <div id="song" class="h-full" tabindex="0" @onkeydown="KeyPress">
        <Virtualize Items="Songs" Context="song">

            <div class="hidden text-orange group-hover:text-white_light">
                @{
                    bool isHighlighted = Song?.ID == song?.ID;
                }
            </div>

            <div class="p-4 bg-gray w-full flex select-none items-center whitespace-pre cursor-pointer group hover:text-white @(isHighlighted ? "bg-primary text-white highlighted" : "text-white_normal")"
            @onclick="async () => { await SelectionChanged(song); }">
                <div class="w-full flex flex-col ">
                    <p class="w-full truncate text-ellipsis overflow-hidden">@Title(song)</p>
                    <p class="w-full truncate text-ellipsis overflow-hidden opacity-75 text-xs">@Secondary(song)</p>
                </div>
                <button class="w-10 h-10 font-ark  @(isHighlighted ? "text-white_light hover:text-gray" : "text-white_normal hover:text-primary")"
                        @onclick="() => { SelectionAddToQueue(song); }" @onclick:stopPropagation="true">A</button>
                <button class="w-10 h-10 font-ark  @(isHighlighted ? "text-white_light" : "text-white_normal") hover:text-red"
                        @onclick="() => { SelectionDelete(song); }" @onclick:stopPropagation="true">D</button>
            </div>
        </Virtualize>
    </div>
}
else
{
    <div class="items-center text-white_normal p-4">
        No songs found
    </div>
}


@code {
    [Inject] IJSRuntime JS { get; set; }
    [Parameter] public List<Song> Songs { get; set; }
    [Parameter] public EventCallback<Song> SelectedSong { get; set; }
    [Parameter] public EventCallback<Song> DeleteSong { get; set; }
    [Parameter] public EventCallback<Song> AddToQueue { get; set; }

    [Parameter] public Song Song { get; set; } = new Song();

    private string titleHighlightKept = "";
    private int ItemCount = 0;
    private int LastIndex = 0;

    private RenderFragment Title(Song song) => (builder) =>
    {
        builder.AddMarkupContent(0, $"{song.Title}");
    };

    private RenderFragment Secondary(Song song) => (builder) =>
    {
        if (song.RawLyrics.Contains("<span class=\"text-orange group-hover:text-white_light\">"))
        {
            string rawLyric = song.RawLyrics.Substring(song.RawLyrics.IndexOf("<span class=\"text-orange group-hover:text-white_light\">", StringComparison.OrdinalIgnoreCase))
                                                 .Replace("\n", " ").Replace("\r", " ");

            rawLyric = rawLyric.Replace("<span class=\"text-orange group-hover:text-white_light\">", "");
            rawLyric = rawLyric.Replace("</span>", "");
            song.LyricHighlighted = rawLyric.Substring(0, Math.Min(rawLyric.Length, 35)) + "...";
            builder.AddMarkupContent(0, $"<span class=\"text-orange group-hover:text-white_light\">{song.LyricHighlighted}</span></br>");
        }

        if (song.Author.Contains("Author") || String.IsNullOrWhiteSpace(song.Author)) return;
        builder.AddMarkupContent(0, $"{song.Author}");
    };


    private async Task ScrollToView(string id) => await JS.InvokeVoidAsync("ScrollToItem", id);

    private async Task SelectionChanged(Song song)
    {

        if (Song.ID != song.ID)
            Song.Title = titleHighlightKept;

        titleHighlightKept = song.Title;

        Song = song;

        await SelectedSong.InvokeAsync(song);

        LastIndex = Songs.FindIndex(s => s.ID == Song.ID);

        await Task.Delay(1); //Delay so the right id will be selected by ScrollToView
        await ScrollToView("song");//
    }

    private async Task KeyPress(KeyboardEventArgs args)
    {
        int index = Songs.FindIndex(s => s.ID == Song.ID);

        if (args.Code == "ArrowDown") index += ((index += 1) >= Songs.Count) ? 0 : 1;
        else if (args.Code == "ArrowUp") index -= ((index -= 1) < 0) ? 0 : 1;

        await SelectionChanged(Songs[index]);
    }
    private async void SelectionDelete(Song song) => await DeleteSong.InvokeAsync(song);
    private async void SelectionAddToQueue(Song song) => await AddToQueue.InvokeAsync(song);
    protected override void OnAfterRender(bool firstRender) 
    { 
        if (firstRender) {
            StateHasChanged();
        }
    }

    protected override void OnParametersSet()
    {
        if (Songs.Count == ItemCount || ItemCount == 0) return;

        if (ItemCount > Songs.Count)
                SelectionChanged(Songs[Math.Clamp(LastIndex, 0, Songs.Count - 1)]);
        else if (ItemCount < Songs.Count)
                SelectionChanged(Songs[Songs.Count - 1]);

        ItemCount = Songs.Count;

    }
    
}
